프로미스 개념을 미리 짚고 넘어가야할 것 같다.
왜냐면 프로미스가 나중에..
지금까지 호출스택이나 스코프 체인말할때는 동기 코드만 말했다..
근데 프로미스 / settimeout / 타이머 / async, await / 비동기 콜백은 비동기...
비동기가 들어오면서 코드분석이 굉장히 어려워졌다..
나같은 경우도 회사에서 정산업무를 하면서 이제 최근에 마감업무하면서 비동기인 async나 await을 많이 썼는데..
운영에서 에러가 나길래 확인해보니까 한 함수 안에 await을 여러개 쓰고..
마지막에 aws lambda invoke를 통해 다른 람다를 불러주고 그 람다 안에서도 await을 사용하면서 쿼리에서 조회를 하고 결과를 보여주는데.. 그게 안보이는거야


프로미스의 개념에 대해 복잡하게 생각하는 분이 많음
프로미스가 뭔지 한문장으로 정리하게되면

프로미스 : 실행이 됐는데. 결과값을 나중에 쓸 수 있는것임! 

나중에 쓸수있는게 엄청난거임! 왜냐면

-> async1
주의할점! 
콜백은 비동기가 아님!
비동기일수도 동기일수도 있음

이런 settimeout의 아쉬운점.. 1초 뒤에 console.log('a')가 바로 실행되어버림
근데 promise의 장점은 모냐..

-> promise1.js
결과값을 나중에 쓸수있다는것
이런식으로 딴짓 (consolelog 같은거) 하다가 promise then을 통해 결과를 사용 가능

setTimeout의 경우 이런식으로 callback을 뺀다고해서 settimeout의 1초가 지나고 바로 실행되는 걸 막지 못함
promise에는 결과값을 담아두고 있다가 언제든 사용가능하다.


근데 보통 promise를 만들자마자 then붙여서 써가지고 잘 몰랐을 수 있다..
나도 몰랐음

->promiseToAsyncAwait
//promise-> async / await으로 막 바꾸면안됨
//async await자체도 promise이기때문에 같이 써야하는 경우가 생김

안되는케이스.

중요한부분..
promise.all 의 catch가
Promise.all([p1, p2, p3, p4, p5])에 대한 캐치라고 생각할수 있는데 아니다!
then까지 전체에 대한 캐치임
then에서 에러나는 것도 catch로감


비동기 : 동기가 아니다. 
비동기는 동시의 개념이 아님.. 동시에 두개 세개가 돌아간다고 생각하면 헷갈림
비동기는 동시의 문제가 아니라 순서의 문제임 : 중요
코드의 작성은 기본적으로 위에서 아래로 왼쪽에서 오른쪽으로 실행이되는데
비동기 코드는 코드 순서와 실제 수행순서가 좀 다르다.

비동기를 동기 코드로 바꾸려고 하는데..
그때 promise코드를 동기 코드를바꾸겠다고 async/await을 쓰게되는데
그게 사실 동기로 만드는 코드가 아님..
그래서 비동기를 async/await을 통해 동기로 만들었다는 틀린말..
한번 비동기는 영원한 비동기임!! 중요

비동기를 동기로 바꾸려는 노력을 아예 하면안됨


async2 도식화시

콜스택에 anonymous함수가 제일 먼저 호출됨

this 는 window 또는 global

그 후 setTimeout호출하고 
0인애라 바로 끝남
settimeout이 빠져나가고..
두번째도 호출하고 settimeout끝나고
세번째도 호출하고 끝나고


anonymous도 끝!
호출스택이 비는데
나중에 보면
a,b,c가 찍힌다! 

비동기 부터는.. 호출스택과 선언지도만으로는 자바스크립트 동작을 분석할수없다.
저번에 했었지!
여기서 동작했던게 이벤트 루프!

background 와 queue 2개.

다시보면..
background에 첫 settimeout 할때 T / fn, 0
두번째 settimeout시 T / fn, 1000
세번째 settimeout시 T / fn, 2000

코드끝나고 콜스택은 비엇으나 우리에겐 backgorund가 비엇다.
backgounr에 타이머가 3개 들어가있음..
bg는 자바스크립트가 아니고 자바스크립트 엔진이라거나,.OS라고 생각하면 편할듯
엔진이기때문에 c++일수도 있으 다른언어일듯 그래서동시에 돌아갈수있다!

자바스크립트는 원래 싱글스레드기때문에 동시라는 개념이 없는데
백그라운드에 들어가는 애들은 동시라는 개념이 생김

promise같은게 
nextTick 같은게 bg에 들어갈수있음
ajax요청같은 네트워크 요청도 들어가고..
이벤트리스너 (클릭 등) 도 들어감

정확히 어떤식으로 들어가는지는 모르더라도
비동기면 적어도 백그라운드를 한번 거치겠구나 생각하면됨

그리고 백그라운드로 들어가면 동시에 여러개를 돌릴수있겠구나~~ 하면됨

아무튼 타이머가 0초짜리면 0초 뒤 비동기 콜백함수 console.log('a') 를 실행하기떄문에
호출스택에 올라가야하는데 , 이때 백그라운드에 간 코드들은
호출스택에 가기전에 태스크큐를 거치게됨 
2개의 큐같은걸 그려봣음
M ㅁㅁㅁ............ 쌓임.. 큐의 특성상 FIFO 선입선출..
m ............

그럼 이벤트 루프가 큐에서 함수들을 하나씩 호출스택으로 올려줌(호출스택이 비어있을때)
1번함수를 하나씩 끌어올려줌
()=>{ console.log('a')} 찍힘 -> 호출스택비워짐
()=>{console.log('b')} 를 호출스택끌어올림 -> 찍힘 -> 호출스택비워짐
() => { console.log('c') } 를 호출스택에 올림 -> 찍힘 -> 호출스택 비워짐

M, m  Macro큐 Micro큐.. 라는데?
micro가 우선순위가 높다.
micro큐에 들어가는거만 알고 있으면 되는데  Promise랑 process.nextTick만!!
나머지 비동기 애들은 macro..

구별해놓은 이유.
이벤트 리스너의 경우 뭐 클릭ㄱ할때라면
클릭이 되는 순간 Macro큐로 들어감
promise는 res/rej되는순간 백그라운드가 마이크로큐로 보내줄거임

혹시나 동시에 들어가는경우( 사실 시간차이가 있긴하지만.) 처리를위해
구별해놓은거임

하나씩들어가면 무조건 micro부터 올라간다..
이벤트루프는 항상 macro/micro둘다 차있는경우 micro를 올리기때무네..
마이크로태스크큐가 꽉차있으면 영원히 매크로태스크는 실행이안됨



async3 마지막에

//호출스택 한번확인해보자!
//anonymous 쌓임 -> a=2 , p= Promise 선언까지는 되고
//프로미스 안이 바로 수행됨
// 익명함수 호출이 스택에 쌓임.
// console.log('hi') 쌓임
// settimeout이 들어오면서 콜백함수/타이머가 백그라운드로감
// console.log(a = 2), 2, 3,
//then을 조심해야되는데 eventlistener처럼 생각하는게 좋음..
//p.then도 백그라운드에다가 p.then fn이 기록됨
//백그라운드는 특정조건이 만족했을때 큐에 보냄
// settimeout은 타이머가 지나면, promise는 resolve함수가 호출되는 것이 매크로/마이크로큐로 가는 조건임

//프로그램 종료 시점은 Callstack과 백그라운드가 전부 빌때!
// 근데 setInterval같이 일정간격으로 계속 수행되는 애가 있다면 영원히 끝나지않음..













